<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bad Apple - Color Match Game</title>
  <style>
    html, body { height:100%; margin:0; background:#000; overflow:hidden; }
    video { display:none; }
    #canvas { display:block; position:absolute; top:0; left:0; right:0; bottom:0; margin:auto; image-rendering:pixelated; background:#000; }

    /* UI overlay */
    #ui {
      position: absolute; left: 12px; top: 12px; z-index: 20; color: white; font-family: system-ui, -apple-system, sans-serif; user-select:none;
      text-shadow: 0 1px 0 rgba(0,0,0,0.6);
    }
    #healthBarWrap { width: 300px; height: 18px; background: rgba(255,255,255,0.08); border-radius: 10px; overflow:hidden; margin-bottom:8px;}
    #healthBar { height:100%; width:100%; background: linear-gradient(90deg, #6ee7b7, #16a34a); transform-origin:left; }
    #controls { margin-top:6px; font-size:14px; }

    /* center overlays */
    #centerOverlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:30; pointer-events:none; }
    #message {
      background: rgba(0,0,0,0.75); color: #fff; padding: 28px 36px; border-radius:12px; font-family:system-ui, -apple-system, sans-serif; font-size:28px; text-align:center; pointer-events:auto;
    }

    #startBtn { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:40; background: rgba(0,0,0,0.7); color:white; padding:20px 36px; font-family:sans-serif; font-size:20px; border-radius:10px; cursor:pointer; }

    #colorIndicator { display:inline-block; width:16px; height:16px; border-radius:3px; vertical-align:middle; margin-right:8px; box-shadow: 0 1px 0 rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.12); }

    #stats { margin-left:12px; display:inline-block; vertical-align:middle; }
  </style>
</head>
<body>
  <div id="startBtn">Bad Apple!!<br><small>Click to start</small></div>
  <video id="video" src="Video.mp4" playsinline></video>
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div id="healthBarWrap"><div id="healthBar"></div></div>
    <div id="controls">
      <span id="colorIndicator"></span>
      <span id="selectedText">Selected: <strong id="selectedColor">WHITE</strong></span>
      <span id="stats">&nbsp;&nbsp;Opposition: <span id="oppositionPct">0%</span></span>
    </div>
    <div style="margin-top:8px; font-size:13px; opacity:0.9;">Toggle color: <strong>E</strong>. Move mouse to match the selected color.<br>Health starts at 250. Reach the end of the video to win.</div>
  </div>

  <div id="centerOverlay" style="display:none;">
    <div id="message"></div>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // UI elements
    const healthBar = document.getElementById('healthBar');
    const colorIndicator = document.getElementById('colorIndicator');
    const selectedColorText = document.getElementById('selectedColor');
    const oppositionPct = document.getElementById('oppositionPct');
    const centerOverlay = document.getElementById('centerOverlay');
    const messageBox = document.getElementById('message');

    // Game state
    let selectedIsWhite = true; // true = white, false = black
    let health = 250;
    const maxHealth = 250;

    // How much damage per second at worst-case (pixel is fully opposite)
    const maxDamagePerSecond = 80; // tweak this for difficulty

    // Track mouse
    let mouseX = 0, mouseY = 0;
    let isPlaying = false;

    // Track canvas CSS display size for coordinate mapping
    function getCanvasScale() {
      const rect = canvas.getBoundingClientRect();
      return { rect, scaleX: canvas.width / rect.width, scaleY: canvas.height / rect.height };
    }

    // Start button behavior
    startBtn.addEventListener('click', async () => {
      startBtn.style.display = 'none';
      try {
        await video.play();
        isPlaying = true;
        setupCanvasSize();
        requestAnimationFrame(loop);
      } catch (err) {
        console.error('Playback error', err);
        alert('Playback failed. Make sure Video.mp4 is present and allowed to autoplay (user gesture required).');
      }
    });

    // Toggle color with E
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'e') toggleColor();
      if (e.key === 'Escape') { /* optional: show/hide UI */ }
    });

    function toggleColor() {
      selectedIsWhite = !selectedIsWhite;
      updateColorUI();
    }

    function updateColorUI() {
      if (selectedIsWhite) {
        colorIndicator.style.background = '#fff';
        selectedColorText.textContent = 'WHITE';
        selectedColorText.style.color = '#fff';
      } else {
        colorIndicator.style.background = '#000';
        selectedColorText.textContent = 'BLACK';
        selectedColorText.style.color = '#fff';
      }
    }

    updateColorUI();

    // Resize & pixel-perfect downscale logic
    function setupCanvasSize() {
      const videoAspect = video.videoWidth / video.videoHeight || 1;
      let targetWidth, targetHeight;
      // Fit into 256 while preserving aspect ratio (this matches your original idea)
      if (videoAspect >= 1) {
        targetWidth = 256;
        targetHeight = Math.floor(256 / videoAspect);
      } else {
        targetHeight = 256;
        targetWidth = Math.floor(256 * videoAspect);
      }

      canvas.width = targetWidth;
      canvas.height = targetHeight;

      // Scale canvas to window but keep aspect
      function resizeCanvas() {
        const windowAspect = window.innerWidth / window.innerHeight;
        let displayWidth, displayHeight;
        if (windowAspect > videoAspect) {
          displayHeight = window.innerHeight;
          displayWidth = displayHeight * videoAspect;
        } else {
          displayWidth = window.innerWidth;
          displayHeight = displayWidth / videoAspect;
        }
        canvas.style.width = Math.round(displayWidth) + 'px';
        canvas.style.height = Math.round(displayHeight) + 'px';
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }

    // Mouse tracking
    window.addEventListener('mousemove', (e) => {
      const { rect, scaleX, scaleY } = getCanvasScale();
      mouseX = (e.clientX - rect.left) * scaleX;
      mouseY = (e.clientY - rect.top) * scaleY;
      // clamp
      mouseX = Math.max(0, Math.min(canvas.width - 1, Math.round(mouseX)));
      mouseY = Math.max(0, Math.min(canvas.height - 1, Math.round(mouseY)));
    });

    // Main loop
    let lastTime = performance.now();
    function loop(now) {
      const dt = (now - lastTime) / 1000; lastTime = now;

      // Draw video to canvas
      if (!canvas.width || !canvas.height) return requestAnimationFrame(loop);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // If playing, check pixel under mouse
      if (isPlaying && !video.paused && !video.ended) {
        // Safety: only try to read pixels if mouse is inside canvas rect
        const { rect } = getCanvasScale();
        const mouseInRect = (mouseX >= 0 && mouseY >= 0 && mouseX < canvas.width && mouseY < canvas.height);

        let opposition = 0; // 0..1, 0 = perfect match, 1 = fully opposite
        if (mouseInRect) {
          try {
            const id = ctx.getImageData(mouseX, mouseY, 1, 1).data;
            const r = id[0], g = id[1], b = id[2];
            const brightness = (r + g + b) / 3; // 0..255

            if (selectedIsWhite) {
              const similarity = brightness / 255; // 1 if white
              opposition = 1 - similarity; // 1 if black
            } else {
              const similarity = 1 - (brightness / 255); // 1 if black
              opposition = 1 - similarity; // 1 if white
            }

            // clamp
            opposition = Math.max(0, Math.min(1, opposition));
            oppositionPct.textContent = Math.round(opposition * 100) + '%';

          } catch (err) {
            // getImageData can throw if canvas is tainted by cross-origin video.
            console.error('getImageData failed (probably CORS):', err);
            oppositionPct.textContent = 'N/A';
          }
        }

        // Damage proportional to opposition and time
        const damage = maxDamagePerSecond * opposition * dt;
        health -= damage;
        health = Math.max(0, health);

        // Update UI health bar
        const healthPct = (health / maxHealth) * 100;
        healthBar.style.width = healthPct + '%';
        // color shift from green -> yellow -> red
        if (healthPct > 60) {
          healthBar.style.background = 'linear-gradient(90deg,#6ee7b7,#16a34a)';
        } else if (healthPct > 30) {
          healthBar.style.background = 'linear-gradient(90deg,#facc15,#f97316)';
        } else {
          healthBar.style.background = 'linear-gradient(90deg,#f87171,#ef4444)';
        }

        // check lose condition
        if (health <= 0) {
          endGame(false);
          return;
        }

        // check win condition: end of video reached
        if (video.ended || video.currentTime >= video.duration - 0.05) {
          endGame(true);
          return;
        }
      }

      // continue
      requestAnimationFrame(loop);
    }

    // End game display
    function endGame(won) {
      isPlaying = false;
      video.pause();
      centerOverlay.style.display = 'flex';
      if (won) {
        messageBox.innerHTML = `<div style="font-size:34px; font-weight:700; margin-bottom:8px;">YOU WIN!</div><div style="font-size:20px;">Score (health): ${Math.round(health)}/${maxHealth}</div><div style="margin-top:10px; font-size:14px; opacity:0.9;">Press R to restart</div>`;
      } else {
        messageBox.innerHTML = `<div style="font-size:34px; font-weight:700; margin-bottom:8px;">YOU LOSE</div><div style="font-size:20px;">Health reached 0</div><div style="margin-top:10px; font-size:14px; opacity:0.9;">Press R to restart</div>`;
      }

      // allow restart with R
      function onKey(e) {
        if (e.key.toLowerCase() === 'r') {
          window.removeEventListener('keydown', onKey);
          restartGame();
        }
      }
      window.addEventListener('keydown', onKey);
    }

    function restartGame() {
      centerOverlay.style.display = 'none';
      health = maxHealth;
      healthBar.style.width = '100%';
      oppositionPct.textContent = '0%';
      video.currentTime = 0;
      video.play().then(() => { isPlaying = true; lastTime = performance.now(); requestAnimationFrame(loop); }).catch(() => {});
    }

    // Defensive: if getImageData throws due to cross-origin video, provide fallback damage based on average brightness of full canvas
    // (This fallback will sample a small area instead of a single pixel.)

    // NOTES: If your Video.mp4 is hosted cross-origin without CORS headers, ctx.getImageData will be blocked. To avoid that, make sure the video file is served from the same origin or served with CORS that allows reading.

    // Initial setup if the user drags mouse early
    canvas.addEventListener('mouseenter', (e) => { const { rect, scaleX, scaleY } = getCanvasScale(); });

    // Update canvas size once metadata is ready
    video.addEventListener('loadedmetadata', () => {
      setupCanvasSize();
    });

    // If video ends naturally, let loop handle the win state; also attach ended event as backup
    video.addEventListener('ended', () => { if (isPlaying) endGame(true); });

    // show a helpful tip overlay before starting
    // (Already handled by startBtn)

    // Prevent context menu on canvas for polish
    canvas.addEventListener('contextmenu', e => e.preventDefault());

  </script>
</body>
</html>
