<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bad Apple - Color Match Game</title>
  <style>
    html, body { height:100%; margin:0; background:#000; overflow:hidden; }
    video { display:none; }
    #canvas { display:block; position:absolute; top:0; left:0; right:0; bottom:0; margin:auto; image-rendering:pixelated; background:#000; }

    /* UI overlay */
    #ui {
      position: absolute; left: 12px; top: 12px; z-index: 20; color: white; font-family: system-ui, -apple-system, sans-serif; user-select:none;
      text-shadow: 0 1px 0 rgba(0,0,0,0.6);
    }
    #healthBarWrap { width: 300px; height: 18px; background: rgba(255,255,255,0.08); border-radius: 10px; overflow:hidden; margin-bottom:8px;}
    #healthBar { height:100%; width:100%; background: linear-gradient(90deg, #6ee7b7, #16a34a); transform-origin:left; }
    #controls { margin-top:6px; font-size:14px; }

    /* center overlays */
    #centerOverlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:30; pointer-events:none; }
    #message {
      background: rgba(0,0,0,0.75); color: #fff; padding: 28px 36px; border-radius:12px; font-family:system-ui, -apple-system, sans-serif; font-size:28px; text-align:center; pointer-events:auto;
    }

    #startBtn { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:40; background: rgba(0,0,0,0.7); color:white; padding:20px 36px; font-family:sans-serif; font-size:20px; border-radius:10px; cursor:pointer; }

    #colorIndicator { display:inline-block; width:16px; height:16px; border-radius:3px; vertical-align:middle; margin-right:8px; box-shadow: 0 1px 0 rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.12); }

    #stats { margin-left:12px; display:inline-block; vertical-align:middle; }
  </style>
</head>
<body>
  <div id="startBtn">Bad Apple!!<br><small>Click to start</small></div>
  <video id="video" src="Video.mp4" playsinline></video>
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div id="healthBarWrap"><div id="healthBar"></div></div>
    <div id="controls">
      <span id="colorIndicator"></span>
      <span id="selectedText">Selected: <strong id="selectedColor">WHITE</strong></span>
      <span id="stats">&nbsp;&nbsp;Opposition: <span id="oppositionPct">0%</span></span>
    </div>
    <div style="margin-top:8px; font-size:13px; opacity:0.9;">Toggle color: <strong>E</strong>. Move mouse to match the selected color.<br>Health starts at 250. Reach the end of the video to win.</div>
  </div>

  <div id="centerOverlay" style="display:none;">
    <div id="message"></div>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // UI elements
    const healthBar = document.getElementById('healthBar');
    const colorIndicator = document.getElementById('colorIndicator');
    const selectedColorText = document.getElementById('selectedColor');
    const oppositionPct = document.getElementById('oppositionPct');
    const centerOverlay = document.getElementById('centerOverlay');
    const messageBox = document.getElementById('message');

    // Game state
    let selectedIsWhite = true; // true = white, false = black
    let health = 250;
    const maxHealth = 250;

    // How much damage per second at worst-case (pixel is fully opposite)
    const maxDamagePerSecond = 80; // tweak this for difficulty

    // Track mouse
    let mouseX = 0, mouseY = 0;
    let isPlaying = false;

    // Track canvas CSS display size for coordinate mapping
    function getCanvasScale() {
      const rect = canvas.getBoundingClientRect();
      return { rect, scaleX: canvas.width / rect.width, scaleY: canvas.height / rect.height };
    }

    // Start button behavior
    startBtn.addEventListener('click', async () => {
      startBtn.style.display = 'none';
      try {
        await video.play();
        isPlaying = true;
        setupCanvasSize();
        requestAnimationFrame(loop);
      } catch (err) {
        console.error('Playback error', err);
        alert('Playback failed. Make sure Video.mp4 is present and allowed to autoplay (user gesture required).');
      }
    });

    // Toggle color with E
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'e') toggleColor();
      if (e.key === 'Escape') { /* optional: show/hide UI */ }
    });

    function toggleColor() {
      selectedIsWhite = !selectedIsWhite;
      updateColorUI();
    }

    function updateColorUI() {
      if (selectedIsWhite) {
        colorIndicator.style.background = '#fff';
        selectedColorText.textContent = 'WHITE';
        selectedColorText.style.color = '#fff';
      } else {
        colorIndicator.style.background = '#000';
        selectedColorText.textContent = 'BLACK';
        selectedColorText.style.color = '#fff';
      }
    }

    updateColorUI();

    // Resize & pixel-perfect downscale logic
    function setupCanvasSize() {
      const videoAspect = video.videoWidth / video.videoHeight || 1;
      let targetWidth, targetHeight;
      // Fit into 256 while preserving aspect ratio (this matches your original idea)
      if (videoAspect >= 1) {
        targetWidth = 256;
        targetHeight = Math.floor(256 / videoAspect);
      } else {
        targetHeight = 256;
        targetWidth = Math.floor(256 * videoAspect);
      }

      canvas.width = targetWidth;
      canvas.height = targetHeight;

      // Scale canvas to window but keep aspect
      function resizeCanvas() {
        const windowAspect = window.innerWidth / window.innerHeight;
        let displayWidth, displayHeight;
        if (windowAspect > videoAspect) {
          displayHeight = window.innerHeight;
          displayWidth = displayHeight * videoAspect;
        } else {
          displayWidth = window.innerWidth;
          displayHeight = displayWidth / videoAspect;
        }
        canvas.style.width = Math.round(displayWidth) + 'px';
        canvas.style.height = Math.round(displayHeight) + 'px';
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }

    // Mouse tracking
    window.addEventListener('mousemove', (e) => {
      const { rect, scaleX, scaleY } = getCanvasScale();
      mouseX = (e.clientX - rect.left) * scaleX;
      mouseY = (e.clientY - rect.top) * scaleY;
      // clamp
      mouseX = Math.max(0, Math.min(canvas.width - 1, Math.round(mouseX)));
      mouseY = Math.max(0, Math.min(canvas.height - 1, Math.round(mouseY)));
    });

    // Main loop
    let lastTime = performance.now();
    function loop(now) {
      const dt = (now - lastTime) / 1000; lastTime = now;

      // Draw video to canvas
      if (!canvas.width || !canvas.height) return requestAnimationFrame(loop);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // If playing, check pixel under mouse
      if (isPlaying && !video.paused && !video.ended) {
        // Safety: only try to read pixels if mouse is inside canvas rect
        const { rect } = getCanvasScale();
        const mouseInRect = (mouseX >= 0 && mouseY >= 0 && mouseX < canvas.width && mouseY < canvas.height);

        let opposition = 0; // 0..1, 0 = perfect match, 1 = fully opposite
        if (mouseInRect) {
          try {
            const id = ctx.getImageData(mouseX, mouseY, 1, 1).data;
            const r = id[0], g = id[1], b = id[2];
            const brightness = (r + g + b) / (255 * 3); // 0=black,1=white approx

            // For white selection, opposition = how dark pixel is (1 - brightness)
            // For black selection, opposition = how bright pixel is (brightness)
            opposition = selectedIsWhite ? (1 - brightness) : brightness;

            // Draw a small circle around mouse to visualize match
            ctx.beginPath();
            ctx.strokeStyle = opposition > 0.5 ? 'red' : 'lime';
            ctx.lineWidth = 2;
            ctx.arc(mouseX + 0.5, mouseY + 0.5, 8, 0, Math.PI * 2);
            ctx.stroke();
          } catch (err) {
            // Sometimes getImageData throws if video not ready
            console.warn('getImageData failed', err);
          }
        }

        // Update health: damage proportional to opposition * maxDamagePerSecond * dt
        health -= opposition * maxDamagePerSecond * dt;
        health = Math.min(maxHealth, Math.max(0, health));

        // Update UI health bar
        healthBar.style.transform = `scaleX(${health / maxHealth})`;

        // Update opposition % UI
        oppositionPct.textContent = Math.round(opposition * 100) + '%';

        // Check game over/win conditions
        if (health <= 0) {
          endGame(false, "You lost! Try again?");
        } else if (video.ended) {
          endGame(true, "You win! Bad Apple conquered!");
        }
      }

      if (isPlaying) requestAnimationFrame(loop);
    }

    // End game
    function endGame(win, msg) {
      isPlaying = false;
      video.pause();
      centerOverlay.style.display = 'flex';
      messageBox.textContent = msg;
      startBtn.style.display = 'block';
      health = maxHealth;
      healthBar.style.transform = 'scaleX(1)';
      oppositionPct.textContent = '0%';
    }
  </script>
</body>
</html>
